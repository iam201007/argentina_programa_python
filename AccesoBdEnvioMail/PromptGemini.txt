Gemini

2.5 Flash

Actualizar



Conversación con Gemini
Hola. Te pido un codigo en python para acceder a una base de datos local access denominada articulos


¡Hola! Aquí tienes un código en Python que te permite conectarte a una base de datos de Microsoft Access (.mdb o .accdb) llamada articulos y realizar una consulta.

Este código utiliza la biblioteca pyodbc, que es la forma más común y confiable de conectarse a bases de datos a través de ODBC (Open Database Connectivity).

Requisitos
Antes de ejecutar el código, asegúrate de tener instalado el controlador de Microsoft Access Database Engine. Si usas una versión de 64 bits de Python, necesitarás la versión de 64 bits del motor de base de datos. Si usas Python de 32 bits, necesitarás la versión de 32 bits.

Puedes descargar el controlador desde el sitio web de Microsoft:

Microsoft Access Database Engine 2010 Redistributable

Microsoft Access Database Engine 2016 Redistributable

Una vez que tengas el controlador, instala la biblioteca pyodbc:

Bash

pip install pyodbc
Código Python
Este ejemplo se conecta a un archivo llamado articulos.accdb y selecciona todos los datos de una tabla llamada Productos.

Python

import pyodbc

# Definir la ruta completa al archivo de la base de datos
db_file_path = "C:\\ruta\\a\\tu\\base\\de\\datos\\articulos.accdb"  # ¡Cambia esto por tu ruta real!

try:
    # Construir la cadena de conexión
    # Usar el driver adecuado según el tipo de archivo (.mdb o .accdb)
    # y la versión del motor de base de datos que instalaste.

    # Para archivos .accdb (Access 2007-2016)
    conn_str = (
        r"DRIVER={Microsoft Access Driver (*.mdb, *.accdb)};"
        f"DBQ={db_file_path};"
    )

    # Para archivos .mdb (Access 2003 y anteriores)
    # conn_str = (
    #    r"DRIVER={Microsoft Access Driver (*.mdb)};"
    #    f"DBQ={db_file_path};"
    # )

    # Establecer la conexión
    cnxn = pyodbc.connect(conn_str)
    cursor = cnxn.cursor()

    print("Conexión exitosa a la base de datos articulos.")

    # Ejecutar una consulta (ejemplo: seleccionar todo de la tabla 'Productos')
    cursor.execute("SELECT * FROM Productos")

    # Recuperar todos los resultados
    rows = cursor.fetchall()

    # Imprimir los resultados
    if rows:
        print("\n--- Datos de la tabla Productos ---")
        for row in rows:
            print(row)
    else:
        print("\nLa consulta no arrojó resultados.")

except pyodbc.Error as ex:
    sqlstate = ex.args[0]
    print(f"Error de conexión o consulta: {sqlstate}")

finally:
    # Asegurarse de cerrar la conexión
    if 'cnxn' in locals() and cnxn:
        cursor.close()
        cnxn.close()
        print("\nConexión cerrada.")

Instrucciones para usar el código:
Reemplaza la línea db_file_path = "C:\\ruta\\a\\tu\\base\\de\\datos\\articulos.accdb" con la ruta completa donde se encuentra tu archivo de Access.

Si tu archivo es .mdb (versiones antiguas), descomenta la segunda cadena de conexión y comenta la primera.

Cambia SELECT * FROM Productos por la consulta que desees, usando el nombre de tu tabla y las columnas que necesites.

Con este código, podrás conectarte y manipular tu base de datos de Access de forma sencilla desde Python. ¡Espero que te sea de gran ayuda!






Te consulto como verificar si en la pc está el controlador de Microsoft Access Database Engine



Mostrar razonamiento
Hola. Para verificar si tienes instalado el controlador de Microsoft Access Database Engine en tu PC, puedes seguir estos pasos:

1. Usar el Administrador de Orígenes de datos ODBC
Esta es la forma más directa y confiable.

Abre el menú de inicio de Windows.

Escribe "Orígenes de datos ODBC" y selecciona la aplicación correspondiente. Es importante que elijas la versión que coincide con la arquitectura de tu sistema (32 bits o 64 bits), ya que hay un administrador para cada una. Si no estás seguro, puedes probar ambos.

En Windows de 64 bits, el administrador de 64 bits está en %systemdrive%\Windows\System32\odbcad32.exe.

El administrador de 32 bits está en %systemdrive%\Windows\SysWoW64\odbcad32.exe.

En la ventana del Administrador de Orígenes de datos ODBC, ve a la pestaña "Controladores" (Drivers).

Busca en la lista el controlador llamado "Microsoft Access Driver (*.mdb, *.accdb)". Si lo encuentras, significa que el controlador está instalado.

2. Verificar en la configuración de "Programas y características"
Si el controlador se instaló de forma independiente, es posible que aparezca en la lista de programas instalados.

Abre el "Panel de control" en Windows.

Ve a "Programas" > "Programas y características".

Busca en la lista de programas instalados algo como "Microsoft Access database engine Redistributable".

3. Usar un archivo Universal Data Link (UDL)
Este método es útil para probar la conectividad OLE DB.

Crea un archivo de texto en tu escritorio y cámbiale la extensión a .udl (por ejemplo, Prueba.udl).

Haz doble clic en el archivo .udl. Se abrirá un cuadro de diálogo.

En la pestaña "Proveedor", podrás ver una lista de los proveedores OLE DB instalados. Busca el proveedor "Microsoft Office 12.0 Access Database Engine OLE DB Provider" o similar.

La presencia de este proveedor indica que el motor de base de datos de Access está instalado.

Aquí tienes un video sobre cómo instalar el driver ODBC para MySQL, lo que te puede dar una idea visual de dónde se encuentran los controladores en el Administrador de Orígenes de datos ODBC.

Guía Completa: Instalación del Driver ODBC para Conexión con MySQL - YouTube








Te pido agregar a la instrucción Select, el parámetro codart = '541339'


Para agregar el filtro WHERE codart = '541339' a la consulta SELECT, simplemente debes modificar la línea donde se ejecuta la consulta.

Aquí tienes el código Python completo y modificado para incluir este parámetro.

Python

import pyodbc

# Definir la ruta completa al archivo de la base de datos
db_file_path = "C:\\ruta\\a\\tu\\base\\de\\datos\\articulos.accdb"  # ¡Cambia esto por tu ruta real!

try:
    # Construir la cadena de conexión
    # Usar el driver adecuado según el tipo de archivo (.mdb o .accdb)
    conn_str = (
        r"DRIVER={Microsoft Access Driver (*.mdb, *.accdb)};"
        f"DBQ={db_file_path};"
    )

    # Establecer la conexión
    cnxn = pyodbc.connect(conn_str)
    cursor = cnxn.cursor()

    print("Conexión exitosa a la base de datos articulos.")

    # Definir el código de artículo que quieres buscar
    codigo_articulo = '541339'

    # Ejecutar la consulta con el parámetro
    # Se usa un placeholder '?' para evitar inyecciones SQL
    cursor.execute("SELECT * FROM Productos WHERE codart = ?", codigo_articulo)

    # Recuperar todos los resultados
    rows = cursor.fetchall()

    # Imprimir los resultados
    if rows:
        print(f"\n--- Datos del artículo con código '{codigo_articulo}' ---")
        for row in rows:
            print(row)
    else:
        print(f"\nNo se encontraron resultados para el código '{codigo_articulo}'.")

except pyodbc.Error as ex:
    sqlstate = ex.args[0]
    print(f"Error de conexión o consulta: {sqlstate}")

finally:
    # Asegurarse de cerrar la conexión
    if 'cnxn' in locals() and cnxn:
        cursor.close()
        cnxn.close()
        print("\nConexión cerrada.")
Explicación de los cambios:
Parámetro en la consulta: La línea cursor.execute("SELECT * FROM Productos WHERE codart = ?", codigo_articulo) ahora usa un placeholder ? en lugar de concatenar el valor directamente. Esto es una buena práctica de seguridad que ayuda a prevenir ataques de inyección SQL.

Variable del parámetro: Se ha creado una variable codigo_articulo = '541339' para que sea más fácil modificar el valor que quieres buscar.

Este código es más seguro y profesional, ya que la biblioteca pyodbc se encarga de pasar el valor de la variable a la consulta de manera correcta.






Muchas gracias !!! Te consulto como puedo buscar varios artículos en lugar de uno solo (541339)


¡De nada! Me alegra que te sea útil.

Para buscar varios artículos en lugar de uno solo, puedes modificar la consulta SELECT usando el operador IN. Este operador te permite especificar una lista de valores.

Código para buscar varios artículos
Aquí tienes el código modificado. En este ejemplo, se buscarán los artículos con los códigos '541339', '123456' y '789012'.

Python

import pyodbc

# Definir la ruta completa al archivo de la base de datos
db_file_path = "C:\\ruta\\a\\tu\\base\\de\\datos\\articulos.accdb"  # ¡Cambia esto por tu ruta real!

try:
    # Construir la cadena de conexión para archivos .accdb
    conn_str = (
        r"DRIVER={Microsoft Access Driver (*.mdb, *.accdb)};"
        f"DBQ={db_file_path};"
    )

    # Establecer la conexión
    cnxn = pyodbc.connect(conn_str)
    cursor = cnxn.cursor()

    print("Conexión exitosa a la base de datos articulos.")

    # Lista de códigos de artículo que quieres buscar
    codigos_a_buscar = ('541339', '123456', '789012')

    # Convertir la lista a una cadena de placeholders '?, ?, ?'
    placeholders = ', '.join('?' * len(codigos_a_buscar))

    # Construir y ejecutar la consulta con el operador IN
    query = f"SELECT * FROM Productos WHERE codart IN ({placeholders})"
    
    # Se usa *codigos_a_buscar para desempaquetar la tupla
    cursor.execute(query, codigos_a_buscar)

    # Recuperar todos los resultados
    rows = cursor.fetchall()

    # Imprimir los resultados
    if rows:
        print(f"\n--- Artículos encontrados ({len(rows)} en total) ---")
        for row in rows:
            print(row)
    else:
        print("\nNo se encontraron artículos para los códigos especificados.")

except pyodbc.Error as ex:
    sqlstate = ex.args[0]
    print(f"Error de conexión o consulta: {sqlstate}")

finally:
    # Asegurarse de cerrar la conexión
    if 'cnxn' in locals() and cnxn:
        cursor.close()
        cnxn.close()
        print("\nConexión cerrada.")
Explicación de los cambios:
Lista de códigos: Creamos una tupla llamada codigos_a_buscar con todos los códigos que queremos encontrar.

Generación de placeholders: La línea placeholders = ', '.join('?' * len(codigos_a_buscar)) es una forma dinámica y segura de crear una cadena de placeholders ('?, ?, ?') que coincide con el número de elementos en tu lista.

Consulta con IN: La consulta SELECT ahora usa WHERE codart IN ({placeholders}). El operador IN le dice a SQL que busque cualquier fila donde el valor de codart esté dentro de la lista que proporcionamos.

Desempaquetar la tupla: Al ejecutar la consulta, pasamos *codigos_a_buscar. El asterisco (*) "desempaqueta" la tupla, lo que significa que pyodbc recibe cada elemento de la tupla como un parámetro separado, en el orden correcto.

Con este código, puedes agregar o quitar códigos de la tupla codigos_a_buscar y el script se ajustará automáticamente para buscarlos a todos.






Te pido agregar los resultados a un dataframe


¡Excelente idea! Utilizar un DataFrame de pandas es la mejor manera de manejar los resultados de una consulta, ya que facilita el análisis, la manipulación y la visualización de los datos.

Para hacer esto, necesitarás instalar la biblioteca pandas si aún no la tienes.

Bash

pip install pandas
Aquí tienes el código completo, modificado para que los resultados de la consulta se guarden directamente en un DataFrame.

Código con DataFrame de Pandas
Python

import pyodbc
import pandas as pd

# Definir la ruta completa al archivo de la base de datos
db_file_path = "C:\\ruta\\a\\tu\\base\\de\\datos\\articulos.accdb"  # ¡Cambia esto por tu ruta real!

try:
    # Construir la cadena de conexión
    conn_str = (
        r"DRIVER={Microsoft Access Driver (*.mdb, *.accdb)};"
        f"DBQ={db_file_path};"
    )

    # Establecer la conexión
    cnxn = pyodbc.connect(conn_str)

    print("Conexión exitosa a la base de datos articulos.")

    # Lista de códigos de artículo que quieres buscar
    codigos_a_buscar = ('541339', '123456', '789012')

    # Convertir la lista a una cadena de placeholders '?, ?, ?'
    placeholders = ', '.join('?' * len(codigos_a_buscar))
    
    # Construir la consulta con el operador IN
    query = f"SELECT * FROM Productos WHERE codart IN ({placeholders})"
    
    # Usar pandas para leer la consulta SQL directamente en un DataFrame
    # Esto es más eficiente que hacerlo de forma manual
    df = pd.read_sql_query(query, cnxn, params=codigos_a_buscar)

    # Imprimir los resultados del DataFrame
    if not df.empty:
        print(f"\n--- Artículos encontrados ({len(df)} en total) ---")
        print(df)
        
        # Ejemplo de cómo acceder a los datos del DataFrame
        print("\n--- Descripción del artículo 541339 ---")
        # Asegúrate de que el nombre de la columna sea el correcto en tu base de datos
        articulo = df[df['codart'] == '541339']
        if not articulo.empty:
             print(articulo['descripcion'].iloc[0])
        else:
             print("No se encontró el artículo 541339 en los resultados.")
    else:
        print("\nNo se encontraron artículos para los códigos especificados.")

except pyodbc.Error as ex:
    sqlstate = ex.args[0]
    print(f"Error de conexión o consulta: {sqlstate}")

finally:
    # Asegurarse de cerrar la conexión
    if 'cnxn' in locals() and cnxn:
        cnxn.close()
        print("\nConexión cerrada.")
Explicación de los cambios:
Importación de pandas: Agregamos import pandas as pd al inicio del script.

pd.read_sql_query(): Esta es la función clave. pandas se encarga de todo el proceso: ejecuta la consulta (query), se conecta a la base de datos (cnxn) y organiza los resultados en un DataFrame. Esto es mucho más limpio y eficiente que recuperar los datos manualmente con cursor.fetchall().

params: El argumento params es donde pasamos la tupla de codigos_a_buscar. pandas maneja de forma segura la inserción de estos valores en los placeholders (?) de la consulta, previniendo la inyección SQL.

Uso del DataFrame: Después de ejecutar la consulta, la variable df contiene un DataFrame con todos los datos. Puedes usar los métodos de pandas para manipular y analizar los datos (por ejemplo, df['codart'] para acceder a la columna de códigos, o df.info() para ver un resumen de la estructura del DataFrame).

Con este enfoque, tienes una herramienta muy poderosa para trabajar con tus datos de forma estructurada y eficiente.






Te consulto como solucionar este error: Execution failed on sql 'SELECT * FROM ARTICULOS WHERE codart IN (?, ?, ?, ?, ?, ?)'

Modifiqué codigos_a_buscar = ('541339')



Hola. Este es un error muy común y me alegra que lo consultes. El problema es que el número de códigos que estás buscando no coincide con el número de marcadores de posición (?) en tu consulta SQL.

El origen del error
Tu mensaje de error muestra la consulta:

SQL

SELECT * FROM ARTICULOS WHERE codart IN (?, ?, ?, ?, ?, ?)
Aquí se están esperando seis códigos de artículo.

Sin embargo, al modificar tu lista a codigos_a_buscar = ('541339'), ahora solo estás proporcionando un código. La cantidad de ? en la consulta debe ser exactamente igual a la cantidad de elementos en tu lista codigos_a_buscar.

La solución
El código que te compartí ya está diseñado para manejar esto de forma automática. El truco está en no modificar manualmente la cadena de la consulta, sino dejar que Python la construya por ti.

Aquí tienes el código correcto y completo. Observa que el cambio es solo en la tupla codigos_a_buscar, y el resto del código se encarga de todo.

Python

import pyodbc
import pandas as pd

# Definir la ruta completa al archivo de la base de datos
db_file_path = "C:\\ruta\\a\\tu\\base\\de\\datos\\articulos.accdb"  # ¡Cambia esto por tu ruta real!

try:
    # Construir la cadena de conexión
    conn_str = (
        r"DRIVER={Microsoft Access Driver (*.mdb, *.accdb)};"
        f"DBQ={db_file_path};"
    )

    # Establecer la conexión
    cnxn = pyodbc.connect(conn_str)

    print("Conexión exitosa a la base de datos articulos.")

    # --- Aquí está el cambio ---
    # Coloca los códigos que desees buscar, incluso si es solo uno.
    # Es importante que lo escribas como una tupla, con la coma al final si es un solo elemento.
    codigos_a_buscar = ('541339',)  # NOTA: La coma hace que sea una tupla de un solo elemento

    # Convertir la tupla a una cadena de placeholders '?, ?, ?'
    placeholders = ', '.join('?' * len(codigos_a_buscar))
    
    # Construir la consulta con el operador IN
    query = f"SELECT * FROM ARTICULOS WHERE codart IN ({placeholders})"
    
    # Usar pandas para leer la consulta SQL directamente en un DataFrame
    df = pd.read_sql_query(query, cnxn, params=codigos_a_buscar)

    # Imprimir los resultados del DataFrame
    if not df.empty:
        print(f"\n--- Artículos encontrados ({len(df)} en total) ---")
        print(df)
    else:
        print("\nNo se encontraron artículos para los códigos especificados.")

except pyodbc.Error as ex:
    sqlstate = ex.args[0]
    print(f"Error de conexión o consulta: {sqlstate}")

finally:
    # Asegurarse de cerrar la conexión
    if 'cnxn' in locals() and cnxn:
        cnxn.close()
        print("\nConexión cerrada.")
Por qué funciona
Tupla de un elemento: Al escribir codigos_a_buscar = ('541339',) (con la coma al final), le indicas a Python que es una tupla, no solo una cadena entre paréntesis.

Generación dinámica: La línea placeholders = ', '.join('?' * len(codigos_a_buscar)) es la que resuelve el problema.

len(codigos_a_buscar) ahora devuelve 1.

'?' * 1 genera la cadena '?'.

', '.join('?') simplemente devuelve '?'.

Consulta correcta: La consulta resultante es SELECT * FROM ARTICULOS WHERE codart IN (?), que coincide perfectamente con el único valor que estás proporcionando.

Con esta estructura, puedes agregar o quitar códigos de la tupla codigos_a_buscar y el código funcionará siempre, sin necesidad de modificar nada más.







Muchas gracias !!!!!. Sí, funcionó la corrección que indicaste --> codigos_a_buscar = ('541339',)


¡Genial! Me alegro mucho de que la corrección haya funcionado y de que ahora el código se ejecute sin problemas. Esos pequeños detalles, como la coma al final de una tupla con un solo elemento, son comunes y a veces difíciles de detectar.

Ahora tienes una forma robusta de buscar cualquier cantidad de artículos, ya sea uno o muchos, sin tener que modificar la consulta SQL cada vez.

Si necesitas hacer alguna otra cosa con tu base de datos o con los datos en el DataFrame de pandas, no dudes en consultarme. ¡Estoy aquí para ayudarte!












Deep Research

Canvas

Imagen

Aprendizaje guiado

Gemini puede cometer errores, así que verifica las respuestas

